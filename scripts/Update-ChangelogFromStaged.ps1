#Requires -Version 5.0
<#
.SYNOPSIS
    Updates the CHANGELOG.md file based on staged changes in Git.

.DESCRIPTION
    This script helps you update the CHANGELOG.md file by:
    1. Showing which files are staged for commit
    2. Allowing you to generate summaries for the changelog
    3. Inserting changes into the Unreleased section

.PARAMETER DryRun
    If specified, shows what would be changed without actually modifying the changelog.

.PARAMETER AutoGenerate
    If specified, attempts to automatically generate changelog entries based on staged files.

.EXAMPLE
    .\Update-ChangelogFromStaged.ps1
    Shows staged files and guides you through updating the changelog.

.EXAMPLE
    .\Update-ChangelogFromStaged.ps1 -DryRun
    Shows what would be added to the changelog without making changes.

.EXAMPLE
    .\Update-ChangelogFromStaged.ps1 -AutoGenerate
    Automatically generates changelog entries based on staged files.

.NOTES
    Author: Your Name
    Date:   $(Get-Date -Format "yyyy-MM-dd")
#>

[CmdletBinding()]
param (
    [Parameter(Mandatory = $false)]
    [switch]$DryRun,

    [Parameter(Mandatory = $false)]
    [switch]$AutoGenerate
)

# Define paths
$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$repoRoot = Split-Path -Parent $scriptDir
$changelogPath = Join-Path $repoRoot "docs\CHANGELOG.md"
$stagedChangesScript = Join-Path $scriptDir "Get-StagedChanges.ps1"

# Check if changelog exists
if (-not (Test-Path $changelogPath)) {
    Write-Error "Changelog file not found at $changelogPath"
    exit 1
}

# Run Get-StagedChanges.ps1 script if it exists
function Get-StagedFilesList {
    if (Test-Path $stagedChangesScript) {
        & $stagedChangesScript
        return & $stagedChangesScript -Format JSON | ConvertFrom-Json
    } else {
        Write-Error "Staged changes script not found at $stagedChangesScript"
        exit 1
    }
}

# Function to extract file extensions
function Get-FileExtensionCategory {
    param (
        [Parameter(Mandatory = $true)]
        [string]$FileName
    )
    
    $extension = [System.IO.Path]::GetExtension($FileName).ToLower()
    
    switch -Wildcard ($extension) {
        ".ps1" { return "PowerShell scripts" }
        ".sh" { return "shell scripts" }
        ".md" { return "documentation" }
        ".json" { return "configuration files" }
        ".yml" { return "configuration files" }
        ".yaml" { return "configuration files" }
        ".js" { return "JavaScript files" }
        ".css" { return "CSS files" }
        ".html" { return "HTML files" }
        ".cs" { return "C# files" }
        ".csproj" { return "project files" }
        ".sln" { return "solution files" }
        ".gitattributes" { return "Git configuration files" }
        ".gitignore" { return "Git configuration files" }
        ".dockerfile" { return "Docker files" }
        "*" { return "files" }
    }
}

# Function to generate changelog entries based on file types and changes
function Get-AutoGeneratedChanges {
    param (
        [Parameter(Mandatory = $true)]
        [object[]]$StagedFiles
    )
    
    $added = @()
    $changed = @()
    $fixed = @()
    
    # Group files by extension category and status
    $groupedFiles = $StagedFiles | Group-Object -Property { Get-FileExtensionCategory -FileName $_.File }, Status
    
    foreach ($group in $groupedFiles) {
        $category, $status = $group.Name -split ', '
        $fileCount = $group.Count
        $plural = if ($fileCount -gt 1) { "s" } else { "" }
        
        $filesList = ($group.Group.File | ForEach-Object { [System.IO.Path]::GetFileName($_) }) -join ', '
        
        switch ($status) {
            "Added" {
                if ($fileCount -eq 1) {
                    $added += "- Added new $category file" + ": " + $filesList
                } else {
                    $added += "- Added $fileCount new $category" + ": " + $filesList
                }
            }
            "Modified" {
                $changed += "- Updated $category ($filesList)"
            }
            "Deleted" {
                $fixed += "- Removed unused $category" + ": " + $filesList
            }
            default {
                $changed += "- $status $category" + ": " + $filesList
            }
        }
    }
    
    return @{
        Added = $added
        Changed = $changed
        Fixed = $fixed
    }
}

# Function to update the changelog
function Update-Changelog {
    param (
        [Parameter(Mandatory = $true)]
        [string]$ChangelogPath,
        
        [Parameter(Mandatory = $true)]
        [string[]]$AddedEntries,
        
        [Parameter(Mandatory = $true)]
        [string[]]$ChangedEntries,
        
        [Parameter(Mandatory = $true)]
        [string[]]$FixedEntries,
        
        [Parameter(Mandatory = $false)]
        [switch]$DryRun
    )
    
    $content = Get-Content $ChangelogPath -Raw
    
    # Find the Unreleased section
    $unreleasedHeaderPattern = '## \[Unreleased\]'
    $addedHeaderPattern = '### Added'
    $changedHeaderPattern = '### Changed'
    $fixedHeaderPattern = '### Fixed'
    
    if ($content -match $unreleasedHeaderPattern) {
        $unreleasedHeader = $Matches[0]
        
        # Find the Added section
        $newContent = $content
        
        if ($AddedEntries.Count -gt 0) {
            $addedEntries = $AddedEntries -join "`n"
            if ($newContent -match "${addedHeaderPattern}\s*\n*(.+?)\n\s*###") {
                $existingAdded = $Matches[1].Trim()
                $newAdded = if ($existingAdded -match '^\s*-') {
                    "$existingAdded`n$addedEntries"
                } else {
                    "$addedEntries"
                }
                $newContent = $newContent -replace "(${addedHeaderPattern}\s*\n*).+?(\n\s*###)", "`$1$newAdded`$2"
            }
        }
        
        if ($ChangedEntries.Count -gt 0) {
            $changedEntries = $ChangedEntries -join "`n"
            if ($newContent -match "${changedHeaderPattern}\s*\n*(.+?)\n\s*###") {
                $existingChanged = $Matches[1].Trim()
                $newChanged = if ($existingChanged -match '^\s*-') {
                    "$existingChanged`n$changedEntries"
                } else {
                    "$changedEntries"
                }
                $newContent = $newContent -replace "(${changedHeaderPattern}\s*\n*).+?(\n\s*###)", "`$1$newChanged`$2"
            }
        }
        
        if ($FixedEntries.Count -gt 0) {
            $fixedEntries = $FixedEntries -join "`n"
            if ($newContent -match "${fixedHeaderPattern}\s*\n*(.+?)(\n\s*##|$)") {
                $existingFixed = $Matches[1].Trim()
                $newFixed = if ($existingFixed -match '^\s*-') {
                    "$existingFixed`n$fixedEntries"
                } else {
                    "$fixedEntries"
                }
                $newContent = $newContent -replace "(${fixedHeaderPattern}\s*\n*).+?(\n\s*##|$)", "`$1$newFixed`$2"
            }
        }
        
        if ($DryRun) {
            Write-Host "`nChanges that would be made to the changelog:" -ForegroundColor Cyan
            
            if ($AddedEntries.Count -gt 0) {
                Write-Host "`n### Added" -ForegroundColor Green
                $AddedEntries | ForEach-Object { Write-Host $_ }
            }
            
            if ($ChangedEntries.Count -gt 0) {
                Write-Host "`n### Changed" -ForegroundColor Yellow
                $ChangedEntries | ForEach-Object { Write-Host $_ }
            }
            
            if ($FixedEntries.Count -gt 0) {
                Write-Host "`n### Fixed" -ForegroundColor Magenta
                $FixedEntries | ForEach-Object { Write-Host $_ }
            }
        } else {
            Set-Content -Path $ChangelogPath -Value $newContent
            Write-Host "Changelog updated successfully!" -ForegroundColor Green
        }
    } else {
        Write-Error "Could not find Unreleased section in the changelog."
        exit 1
    }
}

# Main script execution
Write-Host "Checking for staged changes..." -ForegroundColor Cyan
$stagedFiles = Get-StagedFilesList

if ($null -eq $stagedFiles -or $stagedFiles.Count -eq 0) {
    Write-Host "No files are currently staged for commit. Stage some changes first." -ForegroundColor Yellow
    exit 0
}

# Auto-generate or manually collect changelog entries
$addedEntries = @()
$changedEntries = @()
$fixedEntries = @()

if ($AutoGenerate) {
    Write-Host "Auto-generating changelog entries based on staged files..." -ForegroundColor Cyan
    $generatedChanges = Get-AutoGeneratedChanges -StagedFiles $stagedFiles
    
    $addedEntries = $generatedChanges.Added
    $changedEntries = $generatedChanges.Changed
    $fixedEntries = $generatedChanges.Fixed
} else {
    # Manual entry mode
    Write-Host "`nEnter changelog entries (leave blank to finish each section):" -ForegroundColor Cyan
    
    Write-Host "`nAdded entries:" -ForegroundColor Green
    do {
        $entry = Read-Host "- "
        if ($entry -ne '') {
            $addedEntries += "- $entry"
        }
    } while ($entry -ne '')
    
    Write-Host "`nChanged entries:" -ForegroundColor Yellow
    do {
        $entry = Read-Host "- "
        if ($entry -ne '') {
            $changedEntries += "- $entry"
        }
    } while ($entry -ne '')
    
    Write-Host "`nFixed entries:" -ForegroundColor Magenta
    do {
        $entry = Read-Host "- "
        if ($entry -ne '') {
            $fixedEntries += "- $entry"
        }
    } while ($entry -ne '')
}

# Update the changelog
Update-Changelog -ChangelogPath $changelogPath `
                -AddedEntries $addedEntries `
                -ChangedEntries $changedEntries `
                -FixedEntries $fixedEntries `
                -DryRun $DryRun 